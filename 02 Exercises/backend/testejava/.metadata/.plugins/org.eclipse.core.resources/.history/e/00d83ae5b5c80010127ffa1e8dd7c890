package com.conttroller.securitycontabil.storage;

import com.sun.jna.platform.win32.*;
import com.sun.jna.platform.win32.WinReg.HKEY;
import com.sun.jna.platform.win32.Win32Exception;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Optional;

@Component
public class WindowsRegistryTokenStorage implements TokenStorage {

    private static final Logger logger = LoggerFactory.getLogger(WindowsRegistryTokenStorage.class);

    // Serviço SYSTEM deve usar SEMPRE HKLM
    private static final HKEY ROOT = WinReg.HKEY_LOCAL_MACHINE;
    private static final String REG_PATH = "Software\\Lorttnoc\\Snekot";

    /**
     * Garante que a chave (todos os níveis) exista.
     * Cria nível por nível para compatibilidade com várias versões do JNA.
     */
    private void ensureKeyExists() {
        try {
            // cria "Software" se necessário (normalmente existe)
            if (!Advapi32Util.registryKeyExists(ROOT, "Software")) {
                Advapi32Util.registryCreateKey(ROOT, "Software");
                logger.debug("Criada chave: HKLM\\Software");
            }

            // cria "Software\\Lorttnoc"
            String level1 = "Software\\Lorttnoc";
            if (!Advapi32Util.registryKeyExists(ROOT, level1)) {
                Advapi32Util.registryCreateKey(ROOT, level1);
                logger.debug("Criada chave: HKLM\\{}", level1);
            }

            // cria "Software\\Lorttnoc\\Snekot"
            if (!Advapi32Util.registryKeyExists(ROOT, REG_PATH)) {
                Advapi32Util.registryCreateKey(ROOT, REG_PATH);
                logger.debug("Criada chave: HKLM\\{}", REG_PATH);
            }
        } catch (Exception e) {
            // Não interrompe a execução — lançamos IOException mais acima onde necessário.
            logger.warn("Falha ao garantir existência da chave de registro HKLM\\{}: {}", REG_PATH, e.getMessage());
        }
    }

    @Override
    public void save(String key, String json) throws IOException {
        try {
            ensureKeyExists();

            // Criptografa com DPAPI
            byte[] encrypted = Crypt32Util.cryptProtectData(
                    json.getBytes(StandardCharsets.UTF_8)
            );

            Advapi32Util.registrySetBinaryValue(ROOT, REG_PATH, key, encrypted);
            logger.info("Valor '{}' salvo em HKLM\\{} (tamanho {} bytes)", key, REG_PATH, encrypted.length);

        } catch (Win32Exception w) {
            logger.error("Win32Exception ao salvar no registry: {}", w.getMessage(), w);
            throw new IOException("Erro ao salvar no registry HKLM: " + w.getMessage(), w);
        } catch (Exception e) {
            logger.error("Erro ao salvar no registry: {}", e.getMessage(), e);
            throw new IOException("Erro ao salvar no registry HKLM: " + e.getMessage(), e);
        }
    }

    @Override
    public Optional<String> load(String key) throws IOException {
        try {
            if (!Advapi32Util.registryValueExists(ROOT, REG_PATH, key)) {
                logger.debug("Valor '{}' não existe em HKLM\\{}", key, REG_PATH);
                return Optional.empty();
            }

            byte[] encrypted = Advapi32Util.registryGetBinaryValue(ROOT, REG_PATH, key);

            if (encrypted == null || encrypted.length == 0) {
                logger.debug("Valor '{}' presente mas vazio em HKLM\\{}", key, REG_PATH);
                return Optional.empty();
            }

            byte[] decrypted;
            try {
                decrypted = Crypt32Util.cryptUnprotectData(encrypted);
            } catch (Win32Exception ex) {
                // Falha de DPAPI => valor inválido/no acesso => trata como inexistente
                logger.warn("DPAPI falhou ao descriptografar '{}': {}. Tratando como vazio.", key, ex.getMessage());
                return Optional.empty();
            }

            if (decrypted == null || decrypted.length == 0) {
                logger.debug("Descriptografia retornou vazio para '{}'", key);
                return Optional.empty();
            }

            String result = new String(decrypted, StandardCharsets.UTF_8);
            logger.info("Valor '{}' carregado de HKLM\\{} (tamanho {} bytes)", key, REG_PATH, decrypted.length);
            return Optional.of(result);

        } catch (Win32Exception w) {
            logger.error("Win32Exception ao ler do registry: {}", w.getMessage(), w);
            throw new IOException("Erro ao ler do registry HKLM: " + w.getMessage(), w);
        } catch (Exception e) {
            logger.error("Erro ao ler do registry: {}", e.getMessage(), e);
            throw new IOException("Erro ao ler do registry HKLM: " + e.getMessage(), e);
        }
    }

    @Override
    public void delete(String key) throws IOException {
        try {
            if (Advapi32Util.registryValueExists(ROOT, REG_PATH, key)) {
                Advapi32Util.registryDeleteValue(ROOT, REG_PATH, key);
                logger.info("Valor '{}' deletado de HKLM\\{}", key, REG_PATH);
            } else {
                logger.debug("Tentativa de deletar '{}' mas não existe em HKLM\\{}", key, REG_PATH);
            }
        } catch (Win32Exception w) {
            logger.error("Win32Exception ao deletar do registry: {}", w.getMessage(), w);
            throw new IOException("Erro ao deletar valor no registry: " + w.getMessage(), w);
        } catch (Exception e) {
            logger.error("Erro ao deletar valor no registry: {}", e.getMessage(), e);
            throw new IOException("Erro ao deletar valor no registry: " + e.getMessage(), e);
        }
    }
}