package com.conttroller.securitycontabil.storage;

import com.sun.jna.platform.win32.*;
import com.sun.jna.platform.win32.WinReg.HKEY;
import com.sun.jna.platform.win32.Win32Exception;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Optional;

@Component
public class WindowsRegistryTokenStorage implements TokenStorage {

    private static final Logger logger = LoggerFactory.getLogger(WindowsRegistryTokenStorage.class);

    private static final HKEY ROOT = WinReg.HKEY_LOCAL_MACHINE;
    private static final String REG_PATH = "Software\\Lorttnoc\\Snekot";

    // FLAG para criptografia machine-wide
    private static final int DPAPI_MACHINE_SCOPE = WinCrypt.CRYPTPROTECT_LOCAL_MACHINE;

    private void ensureKeyExists() {
        try {
            if (!Advapi32Util.registryKeyExists(ROOT, "Software")) {
                Advapi32Util.registryCreateKey(ROOT, "Software");
            }

            String level1 = "Software\\Lorttnoc";
            if (!Advapi32Util.registryKeyExists(ROOT, level1)) {
                Advapi32Util.registryCreateKey(ROOT, level1);
            }

            if (!Advapi32Util.registryKeyExists(ROOT, REG_PATH)) {
                Advapi32Util.registryCreateKey(ROOT, REG_PATH);
            }

        } catch (Exception e) {
            logger.warn("Falha ao garantir exist√™ncia da chave: {}", e.getMessage());
        }
    }

    @Override
    public void save(String key, String json) throws IOException {
        try {
            ensureKeyExists();

            // üîê Criptografia MACHINE-WIDE ‚úî
            byte[] encrypted = Crypt32Util.cryptProtectData(
                    json.getBytes(StandardCharsets.UTF_8),
                    null,
                    null,
                    null,
                    null,
                    DPAPI_MACHINE_SCOPE
            );

            Advapi32Util.registrySetBinaryValue(ROOT, REG_PATH, key, encrypted);

            logger.info("Valor '{}' salvo em HKLM\\{} (MACHINE DPAPI)", key, REG_PATH);

        } catch (Exception e) {
            throw new IOException("Erro ao salvar no registry HKLM: " + e.getMessage(), e);
        }
    }

    @Override
    public Optional<String> load(String key) throws IOException {
        try {
            if (!Advapi32Util.registryValueExists(ROOT, REG_PATH, key)) {
                return Optional.empty();
            }

            byte[] encrypted = Advapi32Util.registryGetBinaryValue(ROOT, REG_PATH, key);

            if (encrypted == null || encrypted.length == 0) {
                return Optional.empty();
            }

            byte[] decrypted;

            try {
                decrypted = Crypt32Util.cryptUnprotectData(encrypted);
            } catch (Win32Exception ex) {
                logger.warn("DPAPI falhou ao descriptografar '{}': {}", key, ex.getMessage());
                return Optional.empty();
            }

            if (decrypted == null || decrypted.length == 0) {
                return Optional.empty();
            }

            return Optional.of(new String(decrypted, StandardCharsets.UTF_8));

        } catch (Exception e) {
            throw new IOException("Erro ao ler do registry HKLM: " + e.getMessage(), e);
        }
    }

    @Override
    public void delete(String key) throws IOException {
        try {
            if (Advapi32Util.registryValueExists(ROOT, REG_PATH, key)) {
                Advapi32Util.registryDeleteValue(ROOT, REG_PATH, key);
            }

        } catch (Exception e) {
            throw new IOException("Erro ao deletar valor no registry: " + e.getMessage(), e);
        }
    }
}