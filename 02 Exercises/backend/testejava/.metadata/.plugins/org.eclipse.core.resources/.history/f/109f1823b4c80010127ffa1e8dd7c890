package com.conttroller.securitycontabil.storage;

import com.sun.jna.platform.win32.*;
import com.sun.jna.platform.win32.WinReg.HKEY;
import com.sun.jna.platform.win32.Win32Exception;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Optional;

public class WindowsRegistryTokenStorage implements TokenStorage {

    // Serviço SYSTEM deve usar SEMPRE HKLM
    private static final HKEY ROOT = WinReg.HKEY_LOCAL_MACHINE;
    private static final String REG_PATH = "Software\\Lorttnoc\\Snekot";

    /**
     * Cria a chave se não existir.
     */
    private void ensureKeyExists() {
        if (!Advapi32Util.registryKeyExists(ROOT, REG_PATH)) {
            Advapi32Util.registryCreateKey(ROOT, REG_PATH);
        }
    }

    @Override
    public void save(String key, String json) throws IOException {
        try {
            ensureKeyExists();

            // Criptografa com DPAPI
            byte[] encrypted = Crypt32Util.cryptProtectData(
                    json.getBytes(StandardCharsets.UTF_8),
                    null, null, null, null, 0
            );

            Advapi32Util.registrySetBinaryValue(ROOT, REG_PATH, key, encrypted);

        } catch (Exception e) {
            throw new IOException("Erro ao salvar no registry HKLM: " + e.getMessage(), e);
        }
    }

    @Override
    public Optional<String> load(String key) throws IOException {
        try {
            if (!Advapi32Util.registryValueExists(ROOT, REG_PATH, key)) {
                return Optional.empty();
            }

            byte[] encrypted = Advapi32Util.registryGetBinaryValue(ROOT, REG_PATH, key);

            if (encrypted == null || encrypted.length == 0) {
                return Optional.empty();
            }

            byte[] decrypted;

            try {
                decrypted = Crypt32Util.cryptUnprotectData(encrypted);
            } catch (Win32Exception ex) {
                // Falha de DPAPI => valor inválido => trata como inexistente
                return Optional.empty();
            }

            if (decrypted == null || decrypted.length == 0) {
                return Optional.empty();
            }

            return Optional.of(new String(decrypted, StandardCharsets.UTF_8));

        } catch (Exception e) {
            throw new IOException("Erro ao ler do registry HKLM: " + e.getMessage(), e);
        }
    }

    @Override
    public void delete(String key) throws IOException {
        try {
            if (Advapi32Util.registryValueExists(ROOT, REG_PATH, key)) {
                Advapi32Util.registryDeleteValue(ROOT, REG_PATH, key);
            }
        } catch (Exception e) {
            throw new IOException("Erro ao deletar valor no registry: " + e.getMessage(), e);
        }
    }
}