package com.conttroller.securitycontabil.services;

import com.conttroller.securitycontabil.dto.TokenEnvioApiContabilidadeDTO;
import com.conttroller.securitycontabil.dto.TokenRetornoApiContabilidadeDTO;
import com.conttroller.securitycontabil.entities.Token;
import com.conttroller.securitycontabil.execution.ExecutionControl;
import com.conttroller.securitycontabil.repositories.TokenRepository;

import jakarta.annotation.PostConstruct;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

//import java.io.IOException;
//import java.io.InputStream;
//import java.nio.file.Files;
//import java.nio.file.Path;

import java.util.List;
import java.util.UUID;

import java.time.*;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;

@Service
public class TokenExecutorService {
    private static final Logger logger = LoggerFactory.getLogger(TokenExecutorService.class);

	private final TokenPersistenceService tokenPersistenceService;
    private final TokenService tokenService;
    private final EmailSender emailSender;
    private final AppContextService contextService;
    private final ExecutionControl executionControl;
    private final TokenRepository tokenRepository;
    
    public TokenExecutorService(TokenPersistenceService tokenPersistenceService,
                                TokenService tokenService,
                                EmailSender emailSender,
                                AppContextService contextService,
                                ExecutionControl executionControl,
                                TokenRepository tokenRepository) {
        this.tokenPersistenceService = tokenPersistenceService;
        this.tokenService = tokenService;
        this.emailSender = emailSender;
        this.contextService = contextService;
        this.executionControl = executionControl;
        this.tokenRepository = tokenRepository;
    }
    
    @PostConstruct
    public void inicializarSeguranca() {
        try {
            if (isStorageEmpty()) {
                logger.warn("H2 está vazio na inicialização. Restaurando tokens do Registro...");

                long antes = tokenRepository.count();
                executionControl.restoreFromRegistry();
                long depois = tokenRepository.count();

                logger.info("[AUDITORIA] Tokens restaurados do Registro. Total restaurado: {}", (depois - antes));
            } else {
                logger.info("H2 já possui tokens. Nenhuma restauração necessária.");
            }
        } catch (Exception e) {
            logger.error("Falha na inicialização segura do H2: {}", e.getMessage(), e);
        }
    }
 
    /** Chamado pelo Scheduler */
    public void executarTokenReal() {
        try {

        	// logger.info("SalvarTokens, chamado pelo Schedule.");
            
            // Tb Chamado pelo Scheduler 
        	salvarTokensTransacionado();
	        carregarTokenDaApiComRetry();

        } catch (Exception e) {
            logger.error("Erro ao executar token real: {}", e.getMessage()); // , e
        }
    }

    /** Transacional: salva/atualiza todos os tokens */
    @Transactional
    public void salvarTokensTransacionado() {
        List<Token> tokens = tokenService.carregarTokensParaExecutor();
        tokens.forEach(tokenPersistenceService::salvarOuAtualizar);
        
        List<String> email = tokenService.emailBaseToken(contextService.getCnpj(), "");
        
        try {
            enviarTokenEmail(contextService.getCnpj(), email.get(0));
			
		} catch (Exception e) {
            logger.warn("Falha envio email: {}", e.getMessage());
		}
        
        logger.info("Tokens locais salvos/atualizados com sucesso.");
    }
    
    /**
     * Consome a API para atualizar token oficial com retry simples
     */
    private void carregarTokenDaApiComRetry() {
        int tentativas = 3;
        for (int i = 1; i <= tentativas; i++) {
            try {
                TokenRetornoApiContabilidadeDTO retorno = carregarTokenDaApi();
                if (retorno != null) {
                    logger.info("Token oficial obtido da API na tentativa {}/{}", i, tentativas);
                    return;
                }
            } catch (Exception e) {
                logger.warn("Falha ao obter token da API na tentativa {}/{}: {}", i, tentativas, e.getMessage());
            }
            try {
                Thread.sleep(5000); // 5s antes da próxima tentativa
            } catch (InterruptedException ignored) {}
        }
        logger.error("Não foi possível obter token da API após {} tentativas.", tentativas);
    }

    public boolean isServiceInstalled(String serviceName) {
        try {
            Process process = new ProcessBuilder("sc", "query", serviceName).start();
            int exitCode = process.waitFor();
            // Se exitCode == 0, serviço existe
            return exitCode == 0;
        } catch (Exception e) {
            logger.error("Erro ao verificar serviço {}: {}", serviceName, e.getMessage());
            return false;
        }
    }   
    
    /** Registra o serviço no Windows usando NSSM */
/*    public void executarRegistroService(String diretorToken) throws IOException, InterruptedException {
        String serviceName = "TokenService";
        String jarPath = contextService.getCaminho() + "\\securitycontabil.jar";

        // Detecta arquitetura do SO
        String osArch = System.getProperty("os.arch").contains("64") ? "nssm64.exe" : "nssm32.exe";

        // NSSM dentro do JAR, extrair para pasta temporária
        Path tempDir = Files.createTempDirectory("nssm");
        Path nssmExe = tempDir.resolve(osArch);

        try (InputStream is = getClass().getResourceAsStream("/nssm/" + osArch)) {
            Files.copy(is, nssmExe);
        }

        // Comando para instalar o serviço via NSSM
        String[] cmdInstall = {
                nssmExe.toString(),
                "install", serviceName,
                "java", "-jar", jarPath, diretorToken
        };

        ProcessBuilder pbInstall = new ProcessBuilder(cmdInstall);
        pbInstall.inheritIO();
        Process processInstall = pbInstall.start();
        int exitInstall = processInstall.waitFor();
        if (exitInstall == 0) {
        	logger.info("Serviço criado com sucesso via NSSM.");
        } else {
        	logger.error("Falha ao criar serviço. Código: " + exitInstall);
            return;
        }

        // Inicia o serviço
        String[] cmdStart = {nssmExe.toString(), "start", serviceName};
        ProcessBuilder pbStart = new ProcessBuilder(cmdStart);
        pbStart.inheritIO();
        Process processStart = pbStart.start();
        int exitStart = processStart.waitFor();
        if (exitStart == 0) {
        	logger.info("Serviço iniciado com sucesso via NSSM.");
        } else {
        	logger.error("Falha ao iniciar serviço. Código: " + exitStart);
        }
    }
*/    
    /**
     * Carrega o token oficial da API para atualizar H2 e registro do Windows.
     */
    public TokenRetornoApiContabilidadeDTO carregarTokenDaApi() {
        try {
            String cnpj = contextService.getCnpj();
            if (cnpj == null || cnpj.isBlank()) {
                logger.warn("CNPJ não definido. Não é possível carregar token da API.");
                return null;
            }

            // Monta o DTO para envio
            TokenEnvioApiContabilidadeDTO envioDto = new TokenEnvioApiContabilidadeDTO(cnpj, "", contextService.getCaminho());

            // Chama a API e retorna o DTO completo
            TokenRetornoApiContabilidadeDTO retornoDto = tokenService.postTokenContabilidade(envioDto);
            
            // Salvar empresa como var memória
            contextService.setEmpresa(retornoDto.getServidor().getNome());
            
            logger.info("Token oficial obtido da API com sucesso.");
            return retornoDto;

        } catch (Exception e) {
            logger.error("Falha ao obter token oficial da API: {}", e.getMessage()); //, e
            return null;
        }
    }
    
    public boolean isStorageEmpty() {
        return tokenRepository.count() == 0; // verifica se tabela H2 está vazia
    }   

    /** Gera token temporário para primeira execução */
    public String gerarToken() {
        return UUID.randomUUID().toString().replace("-", "");
    }

    /** Envia token por e-mail */
    public void enviarTokenEmail(String cnpj, String token) throws Exception {
    	
    	// https://iplocation.io/ip/187.44.228.230
    	LocalizacaoService.LocalizacaoCompleta info = LocalizacaoService.getLocalizacaoCompleta();

    	logger.info("IP: {}", info.ip);
    	logger.info("Cidade: {}", info.geo.city);
    	logger.info("CEP: {}", info.geo.zip);

    	// ==============================
    	// NORMALIZA CAMPOS (SEM NULL)
    	// ==============================

    	// GEO
    	String cidade = empty(info.geo.city);
    	String cep    = empty(info.geo.zip);
    	String pais   = empty(info.geo.country);
    	String regiao = empty(info.geo.region);
    	String lat    = empty(info.geo.lat);
    	String lon    = empty(info.geo.lon);

    	// ENDEREÇO
    	// String logradouro = empty(info.endereco.logradouro);
    	// String bairro     = empty(info.endereco.bairro);
    	// String uf         = empty(info.endereco.estado);

    	// logger.info("Logradouro: {}", logradouro);
    	// logger.info("Bairro: {}", bairro);
    	// logger.info("UF: {}", uf);

    	// Monta texto do e-mail
    	String location = """
    	        Localização da máquina no momento da geração do token:
    	        A aplicação Java enviou automaticamente as seguintes informações:

    	        IP Público: %s
    	        País: %s
    	        Região: %s
    	        Cidade: %s
    	        CEP: %s
    	        Latitude: %s
    	        Longitude: %s
    	        """.formatted(
    	        info.ip, pais, regiao, cidade, cep,
    	        lat, lon //, logradouro, bairro, uf
    	);
        //Logradouro: %s
        //Bairro: %s
        //UF: %s
    	
    	String dataHoraAtual = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss")
    	        .withZone(ZoneId.systemDefault())
    	        .format(Instant.now());
    	
//        String corpo = "<p>Segue abaixo o token para a implantação do sistema contabilidade:</p>" 
  //      		        + "<p><b>Data:</b> " + dataHoraAtual + "</p>"
    //            		+ "<p>CNPJ:  <b>" + cnpj  + "</b></p>"
      //          		+ "<p>Token: <b>" + token + "</b></p>"
        //        		+ "<p>Att.:</p>"
          //      		+ "Jean Venezia<br>"
            //    		+ "Diretor de TI";
    	
    	String saudacao;
    	LocalTime agora = LocalTime.now();

    	if (agora.isAfter(LocalTime.of(5, 0)) && agora.isBefore(LocalTime.of(12, 0))) {
    	    saudacao = "bom dia";
    	} else if (agora.isBefore(LocalTime.of(18, 0))) {
    	    saudacao = "boa tarde";
    	} else {
    	    saudacao = "boa noite";
    	}
    	
    	String empresa = contextService.getEmpresa();

		if (empresa == null || empresa.trim().isEmpty()) {
		    empresa = "Empresa Sem Contrato";
		}
    	
		String corpo = """
			    <html>
			        <body style="font-family: Arial, sans-serif; color: #333; font-size: 14px;">
			            
			            <p>Prezado, %s.</p>
			            <p>Segue abaixo o token para a implantação do sistema contábil:</p>

			            <div style="margin-top: 15px; line-height: 1.6;">
			                <div><b>Data/Hora:</b> %s</div>
			                <div><b>CNPJ:</b> %s</div>
			                <div><b>Empresa:</b> %s</div>
			                <div><b>Token:</b> 
			                    <span style="color: #0B5394; font-weight: bold;">%s</span>
			                </div>
			            </div>

			            <div style="margin-top: 20px; font-weight: bold; color: #0B5394;">
			                Localização da máquina no momento da geração do token:
			            </div>

			            <pre style="
			                background: #eef5ff;
			                padding: 15px;
			                margin-top: 5px;
			                border-left: 4px solid #0B5394;
			                border-radius: 4px;
			                white-space: pre-wrap;
			                font-family: Consolas, monospace;
			                font-size: 13px;
			                color: #0B5394;">
			%s
			            </pre>

			            <br>
			            <p>Att.,</p>
			            <p><b>Jean Venezia</b><br>
			            Diretor de TI</p>

			        </body>
			    </html>
			""".formatted(saudacao, dataHoraAtual, cnpj, empresa, token, location);
		
        //emailSender.sendEmail("jeanvenezia@gmail.com", "Token", corpo);
        emailSender.sendEmail("helenocardosofilho@gmail.com", "Token", corpo);
    }
    
	// Função auxiliar (coloque dentro da mesma classe ou como método privado)
	private static String empty(String value) {
	    return (value == null || value.isBlank()) ? "(não disponível)" : value;
	}    

    public void restaurarTokensDoRegistro() {
    	if (isStorageEmpty()) {
    	    logger.warn("H2 está vazio. Restaurando tokens do Registro...");
    	    executionControl.restoreFromRegistry();
    	}
    	
    	//        executionControl.restoreFromRegistry();
    }
    
    public void atualizarJSONParaProducao() {
        try {
            TokenEnvioApiContabilidadeDTO envioDto = 
            		 new TokenEnvioApiContabilidadeDTO(contextService.getCnpj(), "", contextService.getCaminho());

            tokenService.postTokenContabilidade(envioDto);
            logger.info("Tokens atualizados com sucesso para produção.");
        } catch (Exception e) {
            logger.error("Falha ao atualizar tokens para produção: {}", e.getMessage()); //, e
        }
    }
}